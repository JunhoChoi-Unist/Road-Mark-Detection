from cProfile import label
import torch
import numpy as np
w1, w2, w3, w4 = 1, 1, 1, 1

def FourTaskLoss(out, seg, vp, device='cuda'):
    global w1, w2, w3, w4
    CrossEntropyLoss = torch.nn.CrossEntropyLoss()
    L1Loss = torch.nn.L1Loss()

    # Grid Regression L1 Loss

    # gt = torch.Tensor(np.array([np.array([np.array([(min([row.argmax() for row in b]), 3-min([torch.flip(row, dims=[0]).argmax() for row in b]), min([row.argmax() for row in b.transpose(0,1)]), 3-min([torch.flip(row, dims=[0]).argmax() for row in b.transpose(0,1)])) for b in c]) for c in a.view(120,4,640).transpose(1,2).view(120,160,4,4).transpose(2,3)]) for a in seg])).permute(0,3,1,2).to(device)
    # L_reg = L1Loss(out[0], gt)
    # seg = torch.nn.functional.max_pool2d(seg, 4).squeeze(1).to(device)
    L_reg = 1

    # Object Mask Loss
    object_mask = (seg>0).long().to(device)
    L_om = CrossEntropyLoss(out[1], object_mask)
    # Multi Label Loss
    label_mask = torch.nn.functional.max_pool2d(seg, 2)
    label_mask = label_mask.long().to(device)
    L_ml = CrossEntropyLoss(out[2], label_mask)
    # VPP Loss
    L_vp = CrossEntropyLoss(out[3], vp)

    if max(L_reg, L_om, L_ml, L_vp)/min(L_reg, L_om, L_ml, L_vp) > 1.2:
        w2 = w1*L_reg / L_om
        w3 = w1*L_reg / L_ml
        w4 = w1*L_reg / L_vp

    return w1*L_reg + w2*L_om + w3*L_ml + w4*L_vp

def fourPoints(tt):
    indices = tt>0
    
    # Get the minimum and maximum x and y coordinates
    min_x, _ = torch.min(indices, dim=0)
    max_x, _ = torch.max(indices, dim=0)
    
    # Return the left-top and right-bottom coordinates
    left_top = (min_x[1].item(), min_x[0].item())
    right_bottom = (max_x[1].item(), max_x[0].item())
    
    return *left_top, *right_bottom

